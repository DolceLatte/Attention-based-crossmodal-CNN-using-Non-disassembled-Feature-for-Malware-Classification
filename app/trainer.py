
import torch

use_cuda = torch.cuda.is_available()
from sklearn.metrics import classification_report

device = torch.device('cuda')

class trainer():
    def __init__(self,model,trn_loader,val_loader):
        self.model = model
        self.trn_loader = trn_loader
        self.val_loader = val_loader

    def train(self,num_epochs,criterion,optimizer):
        trn_loss_list = []
        val_loss_list = []
        self.model.train()
        self.model.to(device=device)
        for epoch in range(num_epochs):
            trn_loss = 0.0
            for i, (unpack_e, mask ,unpack_i, y) in enumerate(self.trn_loader):
                x = unpack_e
                mask = mask
                x_img = unpack_i
                label = y
                if use_cuda:
                    x = x.cuda()
                    label = label.cuda()
                    mask = mask.cuda()
                    x_img = x_img.cuda()
                # grad init
                optimizer.zero_grad()
                # forward propagation
                model_output, att_score = self.model(x, x_img, mask)
                # calculate loss
                loss = criterion(model_output, label)
                # back propagation
                loss.backward()
                # weight update
                optimizer.step()
                # scheduler.step()
                # trn_loss summary
                trn_loss += loss.item()
                # del (memory issue)
                del loss
                del model_output
                # 학습과정 출력
                if (i + 1) % len(self.trn_loader) == 0:
                    # every 100 mini-batches
                    with torch.no_grad():  # very very very very important!!!
                        val_loss = 0.0
                        corr_num = 0
                        total_num = 0
                        for j, (val_e, val_mask ,val_i, val_y) in enumerate(self.val_loader):
                            val_x = val_e
                            val_img = val_i
                            val_mask = val_mask
                            val_label = val_y

                            if use_cuda:
                                val_x = val_x.cuda()
                                val_img = val_img.cuda()
                                val_mask = val_mask.cuda()
                                val_label = val_label.cuda()

                            val_output, att_score = self.model(val_x, val_img,  val_mask)
                            v_loss = criterion(val_output, val_label)
                            val_loss += v_loss

                            model_label = val_output.argmax(dim=1)
                            corr = val_label[val_label == model_label].size(0)
                            corr_num += corr
                            total_num += val_label.size(0)

                        acc = corr_num / total_num * 100
                        print("acc: {:.2f}".format(acc), end=" ")

                    del val_output
                    del v_loss
                    vvv = val_loss / 17

                    print("epoch: {}/{} | step: {}/{} | trn loss: {:.4f} | val loss: {:.4f}".format(
                        epoch + 1, num_epochs, i + 1, 68, trn_loss / 100, vvv
                    ))

                    trn_loss_list.append(trn_loss / 100)
                    val_loss_list.append(vvv)
                    trn_loss = 0.0

        self.validate()

    def validate(self):
        y_true = []
        y_pred = []

        self.model.eval()

        with torch.no_grad():
            corr_num = 0
            total_num = 0
            for j, (val_e, val_mask ,val_i, val_y) in enumerate(self.val_loader):
                val_x = val_e
                val_img = val_i
                val_mask = val_mask
                val_label = val_y

                if use_cuda:
                    val_x = val_x.cuda()
                    val_img = val_img.cuda()
                    val_mask = val_mask.cuda()
                    val_label = val_label.cuda()

                val_output, att_score = self.model(val_x, val_img,val_mask)
                model_label = val_output.argmax(dim=1)

                y_p = model_label.cpu().numpy().tolist()
                y_t = val_label.cpu().numpy().tolist()

                y_pred += y_p
                y_true += y_t

                corr = val_label[val_label == model_label].size(0)
                corr_num += corr
                total_num += val_label.size(0)

        acc = corr_num / total_num * 100
        print("acc: {:.2f}".format(acc))

        target_names = [
            'Ramnit', 'Lollipop', 'Kelihos ver3',
            'Vundo', 'Simda', 'Tracur',
            'Kelihos ver1', 'Obfuscator.ACY', 'Gatak',
        ]

        print(classification_report(y_true, y_pred, target_names=target_names))

if __name__ == '__main__':
    from app.model.crossmodal import CrossmodalNet
    model = CrossmodalNet()
