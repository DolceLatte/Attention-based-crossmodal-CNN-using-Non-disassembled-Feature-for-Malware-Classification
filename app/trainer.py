from tqdm import tqdm
import torch
use_cuda = torch.cuda.is_available()
from sklearn.metrics import classification_report

class trainer():
    def __init__(self,model,trn_loader,val_loader):
        self.model = model
        self.trn_loader = trn_loader
        self.val_loader = val_loader

    def train(self,num_epochs,criterion,optimizer):
        trn_loss_list = []
        val_loss_list = []
        self.model.train()

        for epoch in range(num_epochs):
            trn_loss = 0.0
            unpack_e , unpack_i = self.trn_loader
            for i, (data, data_img) in enumerate(zip(unpack_e , unpack_i)):
                x, label = data
                x_img, _ = data_img
                if use_cuda:
                    x = x.cuda()
                    label = label.cuda()
                    x_img = x_img.cuda()
                # grad init
                optimizer.zero_grad()
                # forward propagation
                model_output = self.model(x, x_img)
                # calculate loss
                loss = criterion(model_output, label)
                # back propagation
                loss.backward()
                # weight update
                optimizer.step()
                # scheduler.step()
                # trn_loss summary
                trn_loss += loss.item()
                # del (memory issue)
                del loss
                del model_output
                # 학습과정 출력
                if (i + 1) % 68 == 0:
                    # every 100 mini-batches
                    with torch.no_grad():  # very very very very important!!!
                        val_loss = 0.0
                        corr_num = 0
                        total_num = 0
                        unpack_e, unpack_i = self.val_loader
                        for j, (val, val_img) in enumerate(zip(unpack_e, unpack_i)):
                            val_x, val_label = val
                            val_img, _ = val_img

                            if use_cuda:
                                val_x = val_x.cuda()
                                val_img = val_img.cuda()
                                val_label = val_label.cuda()

                            val_output = self.model(val_x, val_img)
                            v_loss = criterion(val_output, val_label)
                            val_loss += v_loss

                            model_label = val_output.argmax(dim=1)
                            corr = val_label[val_label == model_label].size(0)
                            corr_num += corr
                            total_num += val_label.size(0)

                        acc = corr_num / total_num * 100
                        print("acc: {:.2f}".format(acc), end=" ")

                    del val_output
                    del v_loss
                    vvv = val_loss / 17

                    print("epoch: {}/{} | step: {}/{} | trn loss: {:.4f} | val loss: {:.4f}".format(
                        epoch + 1, num_epochs, i + 1, 68, trn_loss / 100, vvv
                    ))

                    trn_loss_list.append(trn_loss / 100)
                    val_loss_list.append(vvv)
                    trn_loss = 0.0

        self.validate()

    def validate(self):
        y_true = []
        y_pred = []

        self.model.eval()

        with torch.no_grad():
            corr_num = 0
            total_num = 0
            unpack_e, unpack_i = self.val_loader
            for j, (val, val_img) in enumerate(zip(unpack_e, unpack_i)):
                val_x, val_label = val
                val_img, _ = val_img

                if use_cuda:
                    val_x = val_x.cuda()
                    val_img = val_img.cuda()
                    val_label = val_label.cuda()

                val_output = self.model(val_x, val_img)
                model_label = val_output.argmax(dim=1)

                y_p = model_label.cpu().numpy().tolist()
                y_t = val_label.cpu().numpy().tolist()

                y_pred += y_p
                y_true += y_t

                corr = val_label[val_label == model_label].size(0)
                corr_num += corr
                total_num += val_label.size(0)

        acc = corr_num / total_num * 100
        print("acc: {:.2f}".format(acc))

        target_names = [
            'Ramnit', 'Lollipop', 'Kelihos ver3',
            'Vundo', 'Simda', 'Tracur',
            'Kelihos ver1', 'Obfuscator.ACY', 'Gatak',
        ]

        print(classification_report(y_true, y_pred, target_names=target_names))